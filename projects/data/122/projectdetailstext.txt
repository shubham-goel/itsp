<p>Our code consists of two parts</p><p>1) thresholding</p><p>#include &lt;iostream&gt;<br>#include "opencv2/highgui/highgui.hpp"<br>#include "opencv2/imgproc/imgproc.hpp"<br><br>using namespace cv;<br>using namespace std;<br><br> int main( int argc, char** argv )<br> {<br>  Mat img=imread("u.jpg");  //read image<br>  Mat imgHSV;<br>  cvtColor(img,imgHSV,COLOR_BGR2HSV);  //convert<br>  namedWindow("threshold",CV_WINDOW_NORMAL);<br>  namedWindow("new",CV_WINDOW_NORMAL);<br>  int ilowh=0;<br>  int ihighh=255;<br>  int ilows=0;<br>  int ihighs=255;<br>  int ilowv=0;<br>  int ihighv=255;   <br>  cvCreateTrackbar("LowH", "threshold", &amp;ilowh, 179); //Hue (0 - 179)<br>  cvCreateTrackbar("HighH", "threshold", &amp;ihighh, 179);<br><br>  cvCreateTrackbar("LowS", "threshold", &amp;ilows, 255); //Saturation (0 - 255)<br>  cvCreateTrackbar("HighS", "threshold", &amp;ihighs, 255);<br><br>  cvCreateTrackbar("LowV", "threshold", &amp;ilowv, 255); //Value (0 - 255)<br>  cvCreateTrackbar("HighV","threshold", &amp;ihighv, 255);<br>   <br>  while(true)<br>  {<br>  Mat imgthresh;<br>  inRange(imgHSV, Scalar(ilowh, ilows, ilowv), Scalar(ihighh, ihighs, ihighv), imgthresh); //Threshold the image<br>  //morphological closing (fill small holes in the foreground)<br>  dilate( imgthresh, imgthresh, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) ); <br>  erode(imgthresh, imgthresh, getStructuringElement(MORPH_ELLIPSE, Size(5, 5)) );<br>  imshow("threshold",imgthresh);<br>  imshow("new",img);<br>  waitKey(20);<br>  }<br>}</p><p>2)Calculating the coordinates of the objects</p><p>#include "opencv2/highgui/highgui.hpp"<br>#include "opencv2/imgproc/imgproc.hpp"<br>#include &lt;iostream&gt;<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br><br>using namespace cv;<br>using namespace std;<br>float a[100],b[100],c[100],d[100];<br>Mat src; Mat imghsv;Mat imgthresh;<br>int thresh = 255;<br>int max_thresh = 255;<br>RNG rng(12345);<br><br>/// Function header<br>void thresh_callback(int, void* );<br><br>/** @function main */<br>int main( int argc, char** argv )<br>{<br>  /// Load source image and convert it to gray<br>  src = imread(argv[1]);<br><br> <br><br>  cvtColor(src,imghsv,COLOR_BGR2HSV);<br><br> int ilowh=9;<br>  int ihighh=27;<br>  int ilows=133;<br>  int ihighs=202;<br>  int ilowv=115;<br>  int ihighv=255;<br> inRange(imghsv, Scalar(ilowh, ilows, ilowv), Scalar(ihighh, ihighs, ihighv), imgthresh); //Threshold the image<br>  blur( imgthresh, imgthresh, Size(3,3) );<br>  /// Create Window<br>  char* source_window = "Source";<br>  namedWindow( source_window, CV_WINDOW_NORMAL );<br>  imshow( source_window, src );<br><br>  createTrackbar( " Canny thresh:", "Source", &amp;thresh, max_thresh, thresh_callback );<br>  thresh_callback( 0, 0 );<br><br>  waitKey(0);<br>  return(0);<br>}<br><br>/** @function thresh_callback */<br><br>void thresh_callback(int, void* )<br>{<br>  Mat canny_output;<br>  vector&lt;vector&lt;Point&gt; &gt; contours;<br>  vector&lt;Vec4i&gt; hierarchy;<br><br>  /// Detect edges using canny<br>  Canny( imgthresh, canny_output, thresh, thresh*2, 3 );<br>  /// Find contours<br>  findContours( canny_output, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, Point(0, 0) );<br><br>  /// Get the moments<br>  vector&lt;Moments&gt; mu(contours.size() );<br>  for( int i = 0; i &lt; contours.size(); i++ )<br>  { mu[i] = moments( contours[i], false ); }<br>float x[contours.size()],y[contours.size()];<br>  ///  Get the mass centers:<br>  vector&lt;Point2f&gt; mc( contours.size() );<br>int j=0;int k;<br>  for( int i = 0; i &lt; contours.size(); i++ )<br>  { mc[i] = Point2f( mu[i].m10/mu[i].m00 , mu[i].m01/mu[i].m00 );<br>  x[i]=mu[i].m10/mu[i].m00; y[i]=mu[i].m01/mu[i].m00;<br>  if(x[i]-x[i-1]&lt;20&amp;&amp;x[i]-x[i-1]&gt;-20&amp;&amp;y[i]-y[i-1]&lt;10&amp;&amp;y[i]-y[i-1]&gt;-10&amp;&amp;i!=0)<br>  {  <br>  }<br>  else<br>  {c[j+1]=x[i];d[j+1]=y[i];<br>j++;k=j;}   <br>  }cout&lt;&lt;k;<br>  for(int m=0;m&lt;k;m++)<br>  {<br>  cout&lt;&lt;endl&lt;&lt;c[m+1]&lt;&lt;"  "&lt;&lt;d[m+1]&lt;&lt;endl;<br>  }<br>cout&lt;&lt;"done"&lt;&lt;endl;<br>  /// Draw contours<br>  Mat drawing = Mat::zeros( canny_output.size(), CV_8UC3 );<br>  for( int i = 0; i&lt; contours.size(); i++ )<br>  {<br>  Scalar color = Scalar( rng.uniform(0, 255), rng.uniform(0,255), rng.uniform(0,255) );<br>  drawContours( drawing, contours, i, color, 2, 8, hierarchy, 0, Point() );<br>  circle( drawing, mc[i], 4, color, -1, 8, 0 );<br>  }<br><br>  /// Show in a window<br>  namedWindow( "Contours", CV_WINDOW_NORMAL);<br>  imshow( "Contours", drawing );<br><br>}</p><br>